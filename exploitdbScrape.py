#!/usr/bin/python

import requests
import os
import logging
import re
import ast
import smtplib

logging.basicConfig(filename='/var/log/exdb/exdb.log',level=logging.DEBUG,format='%(asctime)s %(message)s')


def sendEmail(new_exploits):

		sender = 'exdb@x86.sh'
		receivers = ['jack@x86.sh']

		message = """From:  <exdb@x86.sh>
To: Jack <jack@x86.sh>
Subject: New exploits in EXDB!

See below for latest exploits released on Exploit-DB.
						""" + '\n\n'

		types = ['Remote Exploits', 'Web Application Exploits', 'Local & Privilege Escalation Exploits', 'Denial of Service & Proof of Concept Exploits', 'Exploit Shellcode Archive', 'Archived Security Papers']

		ne_count = 0
		while ne_count < len(new_exploits):
			message += 'Category: ' + types[ne_count] + '\n'
                        message += '-------------------------\n'
			ex_count = 0
			while ex_count < len(new_exploits[ne_count]):
                                Date = str(ast.literal_eval(new_exploits[ne_count][ex_count])['date'])
                                Name = str(ast.literal_eval(new_exploits[ne_count][ex_count])['name'])
                                Platform = str(ast.literal_eval(new_exploits[ne_count][ex_count])['platform'])
                                Link = str(ast.literal_eval(new_exploits[ne_count][ex_count])['link'])
				
                                message += 'Date: ' + Date + '\n'
				message += 'Name: ' + Name + '\n'
				message += 'Platform: ' + Platform + '\n'
				message += 'Link: ' + Link + '\n\n'
				ex_count += 1
			ne_count += 1

		try:
				smtpObj = smtplib.SMTP('localhost')
				smtpObj.sendmail(sender, receivers, message)	
				logging.info("Successfully sent email notification")
				#print message
                except: # SMTPException:
				logging.error("Error: unable to send email")


if __name__ =="__main__":

		# Have to change the user agent to get past block attempts for automated requests
		headers = {'User-Agent': 'Mozilla/5.0'}
		homepage = requests.get('https://www.exploit-db.com/', headers=headers, verify=False)
		indexStr = homepage.text.encode('utf-8')
		indexLi = indexStr.split('\n')

		# line groups for each category
		rce_block = []
		wap_block = []
		priv_block = []
		dos_block = []
		shell_block = []
		paper_block = []

		block_list = [rce_block, wap_block, priv_block, dos_block, shell_block, paper_block]

		# list of dictionaries for each group
		rce = []
		wap = []
		priv = []
		dos = []
		shell = []
		paper = []

		exploit_list = [rce, wap, priv, dos, shell, paper]

		# flags for each group for the loop
		rce_flag = False
		wap_flag = False
		priv_flag = False
		dos_flag = False
		shell_flag = False
		paper_flag = False

		flag_list = [rce_flag, wap_flag, priv_flag, dos_flag, shell_flag, paper_flag]

		count = 0
		while count < (len(indexLi)-1):
			if 'This exploit category includes exploits for remote services or applications' in indexLi[count]:
				rce_flag = True
			elif '</table>' in indexLi[count]:
				rce_flag = False
			elif rce_flag == True:
				rce_block.append(indexLi[count])
			
			if 'This exploit category includes exploits for web applications' in indexLi[count]:
				wap_flag = True
			elif '</table>' in indexLi[count]:
				wap_flag = False
			elif wap_flag == True:
				wap_block.append(indexLi[count])

			if 'This exploit category includes local exploits or privilege escalation exploits' in indexLi[count]:
				priv_flag = True
			elif '</table>' in indexLi[count]:
				priv_flag = False
			elif priv_flag == True:
				priv_block.append(indexLi[count])

			if 'This exploit category includes proof of concept code or code that' in indexLi[count]:
				dos_flag = True
			elif '</table>' in indexLi[count]:
				dos_flag = False
			elif dos_flag == True:
				dos_block.append(indexLi[count])
			
			if 'This category includes archived shellcode' in indexLi[count]:
				shell_flag = True
			elif '</table>' in indexLi[count]:
				shell_flag = False
			elif shell_flag == True:
				shell_block.append(indexLi[count])
			
			if 'Archived security papers and articles in various languages' in indexLi[count]:
				paper_flag = True
			elif '</table>' in indexLi[count]:
				paper_flag = False
			elif paper_flag == True:
				paper_block.append(indexLi[count])

			count += 1


		# Loop through all blocks of HTML and pull out the required into, put info a dict
		block_count = 0
		
		for flag in flag_list:
			flag = False

		while block_count <= (len(block_list)-1):

			lcount = 0
			completed = False

			while lcount < (len(block_list[block_count])-1):

				if '<td class="date">' in block_list[block_count][lcount]:
					date = block_list[block_count][lcount+1].strip()[0:10]
				elif '<td class="dlink">' in block_list[block_count][lcount]:
					start = '<a href="'
					end = '">'
					link = block_list[block_count][lcount+1].strip()[len(start):-len(end)]
				elif '<td class="description">' in block_list[block_count][lcount]:
					if 'title=' in block_list[block_count][lcount+1]:
						result = re.search('.*title="(.*)">', block_list[block_count][lcount+1])
						name = result.group(1)
					else:
						start = '">'
						end = '</a>'
						name = block_list[block_count][lcount+2].strip()[:-4].strip()
				elif '<td class="platform">' in block_list[block_count][lcount]:
					platform = block_list[block_count][lcount+2].strip()[:-4].strip()
					completed = True
				
				if completed == True:
					temp_d = {'name': name, 'date': date, 'link': link, 'platform': platform}
					exploit_list[block_count].append(temp_d)
					completed = False

				lcount += 1
			block_count += 1


		filepaths = ['/opt/exdb/rce.txt', '/opt/exdb/web.txt', '/opt/exdb/privesc.txt', '/opt/exdb/dos.txt', '/opt/exdb/shellcode.txt', '/opt/exdb/papers.txt']

		# Testing filepaths, with old data
		# filepaths = ['/opt/exdb/rce-old.txt', '/opt/exdb/web-old.txt', '/opt/exdb/privesc-old.txt', '/opt/exdb/dos-old.txt', '/opt/exdb/shellcode-old.txt', '/opt/exdb/papers-old.txt']

		# Ensure files exist
		for path in filepaths:
			if not os.path.isfile(path):
				logging.warning(path + ' not found, creating new file.')
				temp = open(path, "w")
				temp.close()

		new_exploits = [[], [], [], [], [], []]
		filecount = 0
		while filecount <= (len(filepaths)-1):
			with open(filepaths[filecount], 'r') as f:
				r_dirty = f.readlines()
			r_list = [x.strip() for x in r_dirty]
			if r_list == ['']:
				w_file = open(filepaths[filecount], 'w')
				for d in exploit_list[filecount]:
					w_file.write(str(d) + '\n')
				w_file.close()
			else:
				new_list = [str(x) for x in exploit_list[filecount]]
				old_list = r_list
				diff = list(set(new_list) - set(old_list))
				for item in diff:
					new_exploits[filecount].append(item)
			filecount += 1
		
		# send the email - if this completes successfully then we overwrite files
		sendEmailFlag = False
		for category in new_exploits:
			if category != []:
				sendEmailFlag = True

		if sendEmailFlag == True:
			sendEmail(new_exploits)
              
			filecount = 0 
			while filecount <= (len(filepaths)-1):
				w_file = open(filepaths[filecount], 'w')
				for d in exploit_list[filecount]:
					w_file.write(str(d) + '\n')
				w_file.close()
				filecount += 1
		else:
			logging.info('No new exploits.')
